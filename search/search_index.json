{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"sc_simvar","text":"<p>A re-implementation of the hotspotsc v1.1.1 Python package using Rust for the computationally intensive portions.</p> <p>Not all code from <code>hotspotsc</code> has been translated to Rust, but all code has been localized.</p> <p>All functions (Rust and Python) are tested to have the exact same output as Hotspotsc for the same input data.</p> <p>Full Docs: https://genentech.github.io/sc_simvar/</p>"},{"location":"#performance","title":"Performance","text":"<p>Using simulated data that varied in the number of genes, cells, and dimensions I ran the pipeline varying whether approx_neighbors or the weighted_graph were used when calculating the knn graph. For the local correlations I used half the number of genes to calculate the correlations on.</p> <p>Across the 108 total simulations performed the mean speed up of <code>SCSimVar</code> over <code>Hotspot</code> was: 3x.</p> <p>Summary of benchmarking results:</p> <p></p> <p>Machine specs:</p> <pre><code>Model Identifier: MacBookPro18,3\nTotal Number of Cores: 8 (6 performance and 2 efficiency)\nMemory: 16 GB\nSystem Version: macOS 14.7.4 (23H420)\nKernel Version: Darwin 23.6.0\nSecure Virtual Memory: Enabled\nMemory: 16 GB\n\nrustc: 1.85.0 (4d91de4e4 2025-02-17)\nPython: 3.10.14\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The <code>SCSimVar</code> class of this package is a direct replacement for the <code>Hotspot</code> class of <code>hotspotsc</code>.</p> <pre><code>from sc_simvar import SCSimVar as Hotspot\n\n# Your old code here, no changes needed.\n</code></pre> <p>If you run into a problem with <code>SCSimVar</code> compared to <code>Hotspot</code> please let me know!</p>"},{"location":"api/","title":"sc_simvar API Reference","text":"<p>The sc_simvar package.</p>"},{"location":"api/#sc_simvar.SCSimVar","title":"SCSimVar","text":"<pre><code>SCSimVar(\n    ann_data: AnnData,\n    layer_key: str | None = None,\n    model: Literal[\n        \"normal\", \"danb\", \"bernoulli\", \"none\"\n    ] = \"danb\",\n    *,\n    latent_obsm_key: str | None = None,\n    distances_obsp_key: str | None = None,\n    tree: TreeNode | None = None,\n    umi_counts_obs_key: str | None = None,\n)\n</code></pre> <p>The SCSimVar class.</p> <p>Initialize the SimVar class.</p> <p>One of <code>obsm_latent_key</code>, <code>obsp_distances_key</code> or <code>tree</code> must be provided.</p> <p>All matrices will be converted to <code>float64</code> for computation. Ensure this does not cause a loss of data/precision.</p> <p>Parameters:</p> Name Type Description Default <code>ann_data</code> <code>AnnData</code> <p>The annotated data matrix, shape is cells x genes.</p> required <code>layer_key</code> <code>str</code> <p>The layer to use for the counts data/matrix, uses <code>X</code> if <code>None</code>.</p> <code>None</code> <code>model</code> <code>Literal['normal', 'danb', 'bernoulli', 'none']</code> <p>The model to use, by default <code>\"danb\"</code>. - 'danb': Depth-Adjusted Negative Binomial - 'bernoulli': Models probability of detection - 'normal': Depth-Adjusted Normal - 'none': Assumes data has been pre-standardized</p> <code>'danb'</code> <code>latent_obsm_key</code> <code>str</code> <p>The key in the <code>AnnData.obsm</code> field containing the cell-cell similarities calculated from euclidean distances. Defaults to <code>None</code>.</p> <code>None</code> <code>distances_obsp_key</code> <code>str</code> <p>The key in the <code>AnnData.obsp</code> field containing the cell-cell distances. Defaults to <code>None</code>.</p> <code>None</code> <code>tree</code> <code>TreeNode</code> <p>Root <code>ete3.TreeNode</code> to calculate cell-cell distances from. Defaults to <code>None</code>.</p> <code>None</code> <code>umi_counts_obs_key</code> <code>str</code> <p>The key in the <code>AnnData.obs</code> field containing the UMI counts. If omitted the sum over the genes in the counts matrix is used. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def __init__(\n    self,\n    ann_data: AnnData,\n    layer_key: str | None = None,\n    model: Literal[\"normal\", \"danb\", \"bernoulli\", \"none\"] = \"danb\",\n    *,\n    latent_obsm_key: str | None = None,\n    distances_obsp_key: str | None = None,\n    tree: TreeNode | None = None,\n    umi_counts_obs_key: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the SimVar class.\n\n    One of `obsm_latent_key`, `obsp_distances_key` or `tree` must be\n    provided.\n\n    All matrices will be converted to `float64` for computation. Ensure\n    this does not cause a loss of data/precision.\n\n    Parameters\n    ----------\n    ann_data : AnnData\n        The annotated data matrix, shape is cells x genes.\n    layer_key : str, optional\n        The layer to use for the counts data/matrix, uses `X` if `None`.\n    model : Literal[\"normal\", \"danb\", \"bernoulli\", \"none\"], optional\n        The model to use, by default `\"danb\"`.\n        - 'danb': Depth-Adjusted Negative Binomial\n        - 'bernoulli': Models probability of detection\n        - 'normal': Depth-Adjusted Normal\n        - 'none': Assumes data has been pre-standardized\n    latent_obsm_key : str, optional\n        The key in the `AnnData.obsm` field containing the cell-cell\n        similarities calculated from euclidean distances. Defaults to\n        `None`.\n    distances_obsp_key : str, optional\n        The key in the `AnnData.obsp` field containing the cell-cell\n        distances. Defaults to `None`.\n    tree : TreeNode, optional\n        Root `ete3.TreeNode` to calculate cell-cell distances from.\n        Defaults to `None`.\n    umi_counts_obs_key : str, optional\n        The key in the `AnnData.obs` field containing the UMI counts.\n        If omitted the sum over the genes in the counts matrix is used.\n        Defaults to `None`.\n\n    \"\"\"\n    self._ann_data = ann_data\n\n    self._validate_knn_key(latent_obsm_key, distances_obsp_key, tree)\n\n    self._model: Literal[\"normal\", \"danb\", \"bernoulli\", \"none\"] = model\n\n    self._layer_key = layer_key\n    self._counts = self._validate_counts()\n    self._umi_counts = self._validate_umi_counts(umi_counts_obs_key)\n\n    self._distances = (\n        None\n        if distances_obsp_key is None\n        else self._convert_to_float64(self._ann_data.obsp[distances_obsp_key])\n    )\n\n    self._latent = (\n        None\n        if latent_obsm_key is None\n        else self._convert_to_float64(self._ann_data.obsm[latent_obsm_key])\n    )\n\n    self._tree = tree\n\n    self._gene_labels: NDArray[str_] = self._ann_data.var_names.to_numpy(dtype=\"U25\")\n    self._cell_labels = self._ann_data.obs_names.to_series()\n\n    # NOTE: these are filled by methods\n    self._neighbors: NDArray[uint64] | None = None\n    self._weights: NDArray[float64] | None = None\n    self._results: DataFrame | None = None\n    self._local_correlation_c: DataFrame | None = None\n    self._local_correlation_z: DataFrame | None = None\n    self._linkage: NDArray[uint64] | None = None\n    self._modules: Series | None = None\n    self._module_scores: DataFrame | None = None\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.linkage","title":"linkage  <code>property</code>","text":"<pre><code>linkage: NDArray[uint64] | None\n</code></pre> <p>The linkage.</p> <p>Returns:</p> Type Description <code>NDArray[uint64] | None</code> <p>The linkage.</p>"},{"location":"api/#sc_simvar.SCSimVar.local_correlation_c","title":"local_correlation_c  <code>property</code>","text":"<pre><code>local_correlation_c: DataFrame | None\n</code></pre> <p>The local correlation C.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The local correlation C.</p>"},{"location":"api/#sc_simvar.SCSimVar.local_correlation_z","title":"local_correlation_z  <code>property</code>","text":"<pre><code>local_correlation_z: DataFrame | None\n</code></pre> <p>The local correlation Z.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The local correlation Z.</p>"},{"location":"api/#sc_simvar.SCSimVar.module_scores","title":"module_scores  <code>property</code>","text":"<pre><code>module_scores: DataFrame | None\n</code></pre> <p>The module scores.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>The module scores.</p>"},{"location":"api/#sc_simvar.SCSimVar.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: Series | None\n</code></pre> <p>The modules.</p> <p>Returns:</p> Type Description <code>Optional[Series[int]]</code> <p>The modules.</p>"},{"location":"api/#sc_simvar.SCSimVar.neighbors","title":"neighbors  <code>property</code>","text":"<pre><code>neighbors: DataFrame | None\n</code></pre> <p>The indices of the neighbors.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>The indices of the neighbors.</p>"},{"location":"api/#sc_simvar.SCSimVar.results","title":"results  <code>property</code>","text":"<pre><code>results: DataFrame | None\n</code></pre> <p>The results.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>The results.</p>"},{"location":"api/#sc_simvar.SCSimVar.weights","title":"weights  <code>property</code>","text":"<pre><code>weights: DataFrame | None\n</code></pre> <p>The weights of the neighbors.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>The weights of the neighbors.</p>"},{"location":"api/#sc_simvar.SCSimVar.calculate_module_scores","title":"calculate_module_scores","text":"<pre><code>calculate_module_scores() -&gt; DataFrame\n</code></pre> <p>Calculate module scores.</p> <p>Returns:</p> Name Type Description <code>module_scores</code> <code>DataFrame</code> <p>A <code>DataFrame</code> of dimensions genes x modules containing the module scores for each gene.</p> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def calculate_module_scores(self) -&gt; DataFrame:\n    \"\"\"Calculate module scores.\n\n    Returns\n    -------\n    module_scores : DataFrame\n        A `DataFrame` of dimensions genes x modules containing the\n        module scores for each gene.\n\n    \"\"\"\n    if self._modules is None or self._linkage is None:\n        raise ValueError(\"No modules or linkage computed, please call the `create_modules` method first.\")\n\n    if self._neighbors is None or self._weights is None:\n        raise ValueError(\n            \"No neighbors or weights computed, please call the `create_knn_graph` method first.\"\n        )\n\n    modules_to_compute: list[int] = sorted([x for x in self._modules.unique() if x != -1])\n\n    print(f\"Computing scores for {len(modules_to_compute)} modules.\")\n\n    module_scores: dict[int, NDArray[Any]] = {}\n    for module in tqdm(modules_to_compute):\n        module_genes = self._modules.index[self._modules == module].to_series()  # type: ignore\n\n        counts_dense = self._counts_from_ann_data(self._ann_data[:, module_genes])\n\n        scores = cast(\n            NDArray[Any],\n            compute_scores(\n                counts_dense,\n                self._model,\n                self._umi_counts,\n                self._neighbors,\n                self._weights,\n            ),\n        )\n\n        module_scores[module] = scores\n\n    self._module_scores = DataFrame(module_scores, index=self._cell_labels)\n\n    return self._module_scores\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.compute_auto_and_local_correlations","title":"compute_auto_and_local_correlations","text":"<pre><code>compute_auto_and_local_correlations(\n    genes: list[str] | NDArray[str_] | None = None,\n) -&gt; tuple[DataFrame, DataFrame]\n</code></pre> <p>Compute the auto and local correlations.</p> <p>Avoids returning to the Python layer between the two computations.</p> <p>Parameters:</p> Name Type Description Default <code>genes</code> <code>list[str] | None</code> <p>The genes to compute the local correlations for, if <code>None</code> all genes are used, by default <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A <code>DataFrame</code> with four columns: - C: Scaled -1:1 autocorrelation coefficients - Z: Z-score for autocorrelation - Pval:  P-values computed from Z-scores - FDR:  Q-values using the Benjamini-Hochberg procedure</p> <code>DataFrame</code> <p>A <code>DataFrame</code> with the local correlations Z scores of dimensions genes x genes.</p> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def compute_auto_and_local_correlations(\n    self, genes: list[str] | NDArray[str_] | None = None\n) -&gt; tuple[DataFrame, DataFrame]:\n    \"\"\"Compute the auto and local correlations.\n\n    Avoids returning to the Python layer between the two computations.\n\n    Parameters\n    ----------\n    genes : list[str] | None, optional\n        The genes to compute the local correlations for, if `None` all\n        genes are used, by default `None`.\n\n    Returns\n    -------\n    DataFrame\n        A `DataFrame` with four columns:\n        - C: Scaled -1:1 autocorrelation coefficients\n        - Z: Z-score for autocorrelation\n        - Pval:  P-values computed from Z-scores\n        - FDR:  Q-values using the Benjamini-Hochberg procedure\n    DataFrame\n        A `DataFrame` with the local correlations Z scores of dimensions\n        genes x genes.\n\n    \"\"\"\n    if self._neighbors is None or self._weights is None:\n        raise ValueError(\n            \"No neighbors or weights computed, please call the `create_knn_graph` method first.\"\n        )\n\n    if genes is None:\n        genes = self._gene_labels\n    elif isinstance(genes, list):\n        genes = array(genes, dtype=\"U25\")\n\n    print(f\"Computing pair-wise local correlation on {len(genes)} features...\")\n\n    all_results = compute_simvar_and_pairs(\n        self._counts,\n        self._counts_from_ann_data(self._ann_data[:, genes]),\n        self._neighbors,\n        self._weights,\n        self._umi_counts,\n        self._gene_labels,\n        self._model,\n        True,\n    )\n\n    self._results = DataFrame(\n        dict(zip([\"C\", \"Z\", \"Pval\", \"FDR\"], all_results[1:5])), index=all_results[0]\n    )\n    self._results.index.name = \"Gene\"\n\n    self._local_correlation_c = DataFrame(all_results[5], index=genes, columns=genes)\n    self._local_correlation_z = DataFrame(all_results[6], index=genes, columns=genes)\n\n    return self._results, self._local_correlation_z\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.compute_autocorrelations","title":"compute_autocorrelations","text":"<pre><code>compute_autocorrelations(jobs: int = 1) -&gt; DataFrame\n</code></pre> <p>Compute the auto correlations.</p> <p>Parameters:</p> Name Type Description Default <code>jobs</code> <code>int</code> <p>Not used.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A <code>DataFrame</code> with four columns: - C: Scaled autocorrelation coefficients - Z: Z-scores for autocorrelation coefficients - Pval: P-values computed from Z-scores - FDR: Adjusted P-values using the Benjamini-Hochberg procedure</p> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def compute_autocorrelations(self, jobs: int = 1) -&gt; DataFrame:\n    \"\"\"Compute the auto correlations.\n\n    Parameters\n    ----------\n    jobs : int, optional\n        Not used.\n\n    Returns\n    -------\n    DataFrame\n        A `DataFrame` with four columns:\n        - C: Scaled autocorrelation coefficients\n        - Z: Z-scores for autocorrelation coefficients\n        - Pval: P-values computed from Z-scores\n        - FDR: Adjusted P-values using the Benjamini-Hochberg procedure\n\n    \"\"\"\n    if self._neighbors is None or self._weights is None:\n        raise ValueError(\n            \"No neighbors or weights computed, please call the `create_knn_graph` method first.\"\n        )\n\n    results = compute_simvar(\n        self._counts,\n        self._neighbors,\n        self._weights,\n        self._umi_counts,\n        self._gene_labels,\n        self._model,\n        True,\n    )\n\n    self._results = DataFrame(dict(zip([\"C\", \"Z\", \"Pval\", \"FDR\"], results[1:])), index=results[0])\n    self._results.index.name = \"Gene\"\n\n    return self._results\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.compute_local_correlations","title":"compute_local_correlations","text":"<pre><code>compute_local_correlations(\n    genes: list[str] | NDArray[str_] | None = None,\n    jobs: int = 1,\n) -&gt; DataFrame\n</code></pre> <p>Compute the local correlations.</p> <p>Parameters:</p> Name Type Description Default <code>genes</code> <code>list[str] | None</code> <p>The genes to compute the local correlations for, if <code>None</code> all genes are used, by default <code>None</code>.</p> <code>None</code> <code>jobs</code> <code>int</code> <p>Not used.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A <code>DataFrame</code> with the local correlations Z scores of dimensions genes x genes.</p> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def compute_local_correlations(\n    self, genes: list[str] | NDArray[str_] | None = None, jobs: int = 1\n) -&gt; DataFrame:\n    \"\"\"Compute the local correlations.\n\n    Parameters\n    ----------\n    genes : list[str] | None, optional\n        The genes to compute the local correlations for, if `None` all\n        genes are used, by default `None`.\n    jobs : int, optional\n        Not used.\n\n    Returns\n    -------\n    DataFrame\n        A `DataFrame` with the local correlations Z scores of dimensions\n        genes x genes.\n\n    \"\"\"\n    if self._neighbors is None or self._weights is None:\n        raise ValueError(\n            \"No neighbors or weights computed, please call the `create_knn_graph` method first.\"\n        )\n\n    if genes is None:\n        genes = self._gene_labels\n    elif isinstance(genes, list):\n        genes = array(genes, dtype=\"U25\")\n\n    print(f\"Computing pair-wise local correlation on {len(genes)} features...\")\n\n    lcps, zs = compute_simvar_pairs_centered_cond(\n        self._counts_from_ann_data(self._ann_data[:, genes]),\n        self._neighbors,\n        self._weights,\n        self._umi_counts,\n        self._model,\n    )\n\n    self._local_correlation_c = DataFrame(lcps, index=genes, columns=genes)\n    self._local_correlation_z = DataFrame(zs, index=genes, columns=genes)\n\n    return self._local_correlation_z\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.create_knn_graph","title":"create_knn_graph","text":"<pre><code>create_knn_graph(\n    weighted_graph: bool = False,\n    n_neighbors: int = 30,\n    neighborhood_factor: int = 3,\n    approx_neighbors: bool = True,\n) -&gt; None\n</code></pre> <p>Create a k-nearest neighbor graph.</p> <p>Parameters:</p> Name Type Description Default <code>weighted_graph</code> <code>bool</code> <p>Whether to create a weighted graph, by default <code>False</code>.</p> <code>False</code> <code>n_neighbors</code> <code>int</code> <p>The number of nearest neighbors to use, by default <code>30</code>.</p> <code>30</code> <code>neighborhood_factor</code> <code>int</code> <p>The number of neighbors to approximate the full graph with, by default <code>3</code>.</p> <code>3</code> <code>approx_neighbors</code> <code>bool</code> <p>Whether to approximate the neighbors, by default <code>True</code>.</p> <code>True</code> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def create_knn_graph(\n    self,\n    weighted_graph: bool = False,\n    n_neighbors: int = 30,\n    neighborhood_factor: int = 3,\n    approx_neighbors: bool = True,\n) -&gt; None:\n    \"\"\"Create a k-nearest neighbor graph.\n\n    Parameters\n    ----------\n    weighted_graph : bool, optional\n        Whether to create a weighted graph, by default `False`.\n    n_neighbors : int, optional\n        The number of nearest neighbors to use, by default `30`.\n    neighborhood_factor : int, optional\n        The number of neighbors to approximate the full graph with,\n        by default `3`.\n    approx_neighbors : bool, optional\n        Whether to approximate the neighbors, by default `True`.\n\n    \"\"\"\n    if self._latent is not None:\n        neighbors, weights = latent_neighbors_and_weights(\n            self._latent,\n            n_neighbors,\n            neighborhood_factor,\n            approx_neighbors,\n        )\n    elif self._distances is not None:\n        neighbors, weights = distances_neighbors_and_weights(\n            self._distances,\n            n_neighbors,\n            neighborhood_factor,\n        )\n    elif self._tree is not None:\n        neighbors, weights = tree_neighbors_and_weights(\n            self._tree,\n            n_neighbors=n_neighbors,\n            cell_labels=self._cell_labels.to_list(),\n        )\n    else:\n        # NOTE: should never happen due to checks in __init__\n        raise ValueError(\"No latent space or distances provided.\")\n\n    if not weighted_graph:\n        weights = ones_like(weights)\n    weights = make_weights_non_redundant(weights, neighbors)\n    self._neighbors = neighbors\n    self._weights = weights\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.create_modules","title":"create_modules","text":"<pre><code>create_modules(\n    min_gene_threshold: int = 20,\n    core_only: bool = True,\n    fdr_threshold: float = 0.05,\n) -&gt; Series\n</code></pre> <p>Group genes into modules.</p> <p>Parameters:</p> Name Type Description Default <code>min_gene_threshold</code> <code>int</code> <p>The minimum number of genes in a module, decrease if too many modules are formed, decrease if sub-structure is not being captured. Defaults to <code>20</code>.</p> <code>20</code> <code>core_only</code> <code>bool</code> <p>If <code>False</code> genes which cannot be unambiguously assigned to a module are instead assigned to a noise module indicated as <code>-1</code> in the results. If <code>True</code> they are assigned to the likeliest module. Defaults to <code>True</code>.</p> <code>True</code> <code>fdr_threshold</code> <code>float</code> <p>The FDR threshold to use for module assignment, defaults to <code>0.05</code>.</p> <code>0.05</code> <p>Returns:</p> Type Description <code>Series</code> <p>A <code>Series</code> with the module assignments for each gene, unassigned genes are indicated with <code>-1</code>.</p> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def create_modules(\n    self,\n    min_gene_threshold: int = 20,\n    core_only: bool = True,\n    fdr_threshold: float = 0.05,\n) -&gt; Series:\n    \"\"\"Group genes into modules.\n\n    Parameters\n    ----------\n    min_gene_threshold : int, optional\n        The minimum number of genes in a module, decrease if too many\n        modules are formed, decrease if sub-structure is not being\n        captured. Defaults to `20`.\n    core_only : bool, optional\n        If `False` genes which cannot be unambiguously assigned to a module\n        are instead assigned to a noise module indicated as `-1` in the\n        results. If `True` they are assigned to the likeliest module.\n        Defaults to `True`.\n    fdr_threshold : float, optional\n        The FDR threshold to use for module assignment, defaults to `0.05`.\n\n    Returns\n    -------\n    Series\n        A `Series` with the module assignments for each gene, unassigned\n        genes are indicated with `-1`.\n\n    \"\"\"\n    if self._local_correlation_z is None:\n        raise ValueError(\n            \"No local correlations computed, please call the `compute_local_correlations` method first.\"\n        )\n\n    self._modules, self._linkage = compute_modules(\n        self._local_correlation_z,\n        min_gene_threshold=min_gene_threshold,\n        fdr_threshold=fdr_threshold,\n        core_only=core_only,\n    )\n\n    return self._modules\n</code></pre>"},{"location":"api/#sc_simvar.SCSimVar.plot_local_correlation","title":"plot_local_correlation","text":"<pre><code>plot_local_correlation(\n    mod_cmap: str | Colormap = \"tab10\",\n    vmin: int = -8,\n    vmax: int = 8,\n    z_cmap: str | Colormap = \"RdBu_r\",\n    yticklabels: bool = False,\n) -&gt; None\n</code></pre> <p>Plot a cluster-grid of the local correlation values.</p> <p>Parameters:</p> Name Type Description Default <code>mod_cmap</code> <code>str | Colormap</code> <p>Valid <code>matplotlib</code> colormap <code>str</code> or a <code>ColorMap</code> from the <code>matplotlib.colormaps</code> for module assignments on the left side.</p> <code>'tab10'</code> <code>vmin</code> <code>int</code> <p>Min value for Z-scores color scale. Default is <code>-8.0</code>.</p> <code>-8</code> <code>vmax</code> <code>int</code> <p>Max value for Z-scores color scale. Default is <code>8.0</code>.</p> <code>8</code> <code>z_cmap</code> <code>str | Colormap</code> <p>Valid <code>matplotlib</code> colormap <code>str</code> or a <code>ColorMap</code> from the <code>matplotlib.colormaps</code> for correlation Z-scores.</p> <code>'RdBu_r'</code> <code>yticklabels</code> <code>bool</code> <p>If <code>True</code> plot all gene labels on the Y-axis. Useful if using plot interactively and can zoom in, otherwise there are too many genes. Default is <code>False</code>.</p> <code>False</code> Source code in <code>src/sc_simvar/_sc_simvar.py</code> <pre><code>def plot_local_correlation(\n    self,\n    mod_cmap: str | Colormap = \"tab10\",\n    vmin: int = -8,\n    vmax: int = 8,\n    z_cmap: str | Colormap = \"RdBu_r\",\n    yticklabels: bool = False,\n) -&gt; None:\n    \"\"\"Plot a cluster-grid of the local correlation values.\n\n    Parameters\n    ----------\n    mod_cmap : str | Colormap, optional\n        Valid `matplotlib` colormap `str` or a `ColorMap` from the\n        `matplotlib.colormaps` for module assignments on the left side.\n    vmin : int, optional\n        Min value for Z-scores color scale. Default is `-8.0`.\n    vmax : int, optional\n        Max value for Z-scores color scale. Default is `8.0`.\n    z_cmap : str | Colormap, optional\n        Valid `matplotlib` colormap `str` or a `ColorMap` from the\n        `matplotlib.colormaps` for correlation Z-scores.\n    yticklabels: bool, optional\n        If `True` plot all gene labels on the Y-axis. Useful if using plot\n        interactively and can zoom in, otherwise there are too many genes.\n        Default is `False`.\n\n    \"\"\"\n    if self._local_correlation_z is None:\n        raise ValueError(\n            \"No local correlations computed, please call the `compute_local_correlations` method first.\"\n        )\n\n    if self._modules is None or self._linkage is None:\n        raise ValueError(\"No modules or linkage computed, please call the `create_modules` method first.\")\n\n    local_correlation_plot(\n        self._local_correlation_z,\n        self._modules,\n        self._linkage,\n        mod_cmap=mod_cmap,\n        vmin=vmin,\n        vmax=vmax,\n        z_cmap=z_cmap,\n        yticklabels=yticklabels,\n    )\n</code></pre>"},{"location":"authors/","title":"Contributors","text":"<ul> <li>hargreaw hargreaw@gene.com</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v031","title":"v0.3.1","text":"<ul> <li>Fix: replace compute_weights hotspotsc import with sc_simvar._lib</li> </ul>"},{"location":"changelog/#v030","title":"v0.3.0","text":"<ul> <li>Enhancement: increased speedup of Rust code dramatically using Github Co-Pilot with Claude, now at 3x</li> <li>Enhancement: added improved benchmarking and results</li> <li>Change: removed unused Rust code</li> </ul>"},{"location":"changelog/#v020","title":"v0.2.0","text":"<ul> <li>Change: updated tools for managing and building the project</li> <li>Change: transcribed remaining hotspotsc functions to local functions (some will be moved to Rust in a future release)</li> <li>Change: updated Rust crate versions to latest, modified code to work with them</li> </ul>"},{"location":"changelog/#v011","title":"v0.1.1","text":"<ul> <li>Change: building with manylinux container directly resulted in a very slow package we now build with maturin manylinux container which seems to have fixed the issue</li> </ul>"},{"location":"changelog/#v010","title":"v0.1.0","text":"<ul> <li>Implements all of the functionality of the <code>Hotspot</code> class in the <code>SCSimVar</code> class.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions and bug reports from the community are welcome!</p>"},{"location":"contributing/#future-work","title":"Future work","text":"<p>If time permits:</p> <ul> <li>Make test suite even more comprehensive.</li> <li>Move what remaining Python code that can be moved to Rust to Rust (most of the code in the src/sc_simvar/_not_yet_rust directory)</li> <li>Code that relies on complex code from other libraries (like sklearn) will most likely remain Python</li> </ul>"},{"location":"contributing/#versioning","title":"Versioning","text":"<p>We try to abide by Semantic Versioning.</p> <ul> <li>Bug fixes get a PATCH bump</li> <li>Back compatible changes get a MINOR bump</li> <li>API breaking changes get a MAJOR bump</li> </ul> <p>Sometimes we may bump MAJOR because we feel like we, or the repo, deserves it.</p>"},{"location":"contributing/#setup-testing","title":"Setup &amp; Testing","text":"<p>To develop this project you need to have Rust and uv installed.</p> <p>The <code>pyproject.toml</code> uses Maturin to build the Rust code, etc. so you can build and test this project in the usual way with uv:</p> <pre><code>uv sync\nuv run pytest\n</code></pre> <p>If you make changes to the Rust code you will like have to run the command:</p> <pre><code>uv sync --reinstall-package sc_simvar\n</code></pre> <p>To get your latest changes into the <code>uv</code> <code>.venv</code> as Rust code changes aren't part of the editable install of the Python code.</p>"},{"location":"contributing/#docs","title":"Docs","text":"<p>The docs are created using mkdocs with the Material for MkDocs theme.</p>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2025 Genentech</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}